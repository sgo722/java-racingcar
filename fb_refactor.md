# 피드백 이후 수정
1. 패키지 구조 변경
2. InputView 추가
3. Cars 일급 컬렉션 생성
4. Result 인터페이스 생성
5. RandomNumberGenerator 객체 생성
6. OutputView로 출력 기능 분리


# 생각하며 피드백 수정
1. 패키지 설계
   1. 레이어드 / 모듈 별로 나누는게 큰 틀이라고 하는 것 같다.
   3. 내가 왜 이런 패키지 구조를 명확한 왜가 없다. 구조를 나눌 때 이해하기 편했으니까?정도다.
   -> 도메인 단위로 나눠 코드를 쳤긴한데 둘 중 어디쪽에 속하는지 또 왜 이 방식을 채택했는지에 대한 명확한 이유가 없다.

2. 객체 이름 변경
    1. InputMessage -> InputView /  OutputMessage -> OutputView
        - 두 객체 모두 화면에 종속된 객체들이기 떄문에 View라는 단어가 더 납득이 될 것 같아 수정했습니다.

3. 일급컬렉션
    1. Cars라는 일급 컬렉션을 생성해서 상태와 행위를 한번에 관리한다.
        1. CarGameManager에만 지나친 책임을 분산시킬 수 있었다.
            - 자동차 생성 기능
            - 자동차 게임 결과 출력 기능
        2. CarGameService 객체를 삭제하였다.
            - 게임 운영과 게임 실행의 명확한 분리가 안됐고, 게임을 실행한다는 새로운 객체보다 일급컬렉션으로 상태와 행위를 관리하는 객체로 해결하는게 더 낫다고 생각했습니다.

4. 클린코드
    1. 메소드 접근자에 따른 위치 분리
        - 가독성 향상을 위해 public 상단 / private 하단에 위치시켰습니다.
    2. if-else 지양하라.
        - 출력문 if-else문 제거 -> if문으로 대체
    3. 매직넘버 제거
        - 랜덤숫자 중 의미있는 숫자는 상수로 치환

5. 인터페이스 적용(OCP / DI)
    1. Result 인터페이스 생성
        - 결과 출력에 대한 요구사항 변경이 일어나도 대응할 수 있습니다.
        - 요구사항에 맞춰 Result의 구현체를 만들면 되기 때문에 확장성을 확보했다고 생각합니다.
        - 결과 객체를 의존성 주입을 받아 OCP를 확보했다고 생각합니다.

6. 객체지향
    1. 단일책임원칙
        2. RandomNumberGenerator 생성
            - Car 객체가 랜덤숫자 생성, 판단까지 담당하고 있었기에 랜덤 숫자를 생성하는 객체르 만들어 분리했습니다.

7. 불변객체
   1. MoveCount를 불변객체로 만들려는 시도 중 MoveCount 객체를 반환하면 Car가 불변을 유지하지 못하는데 어떡해야하나..
      -> 가변 객체로 불변 객체로 바꾸면서 연쇄적으로 코드를 변경이 일어났다. 어색하고 귀찮았지만 불변객체의 장점이 더 크다고 생각한다.

8. 예외처리
   1. 어디에서 할 것인가?
      - View와 Model 두 곳에서 모두 검증한다.
      - View는 입력 값의 형식(숫자인지, 빈칸은 아닌지) 검증을 진행한다.
      - Model은 View에서 검증하는 것 + 비즈니스 로직의 검증(글자 수, 이름 조건)까지 진행한다.

   2. 에러메시지를 모을 것인가? 
      1. 상수클래스에 에러메시지를 모아보았다.
         - 모아놓으면 유지보수성이 확보될 수 있다고 생각했다.
         - 어디에서 쓰는지 주석처리를 통해 구분한다면 가독성을 확보할 수 있을 거라 생각했다.
         - 상수클래스가 엄청나게 크다면? 프로퍼티
      2. Enum이 아닌 상수 클래스를 사용한 이유
         - Enum을 사용하면 객체 반환할 떄 get메서드로 참조되어야하기에 코드 가독성이 떨어진다고 생각함.(= 깔끔하지 못하다)
         - 단순 상수 클래스이고, 행위가 없기때문에 상수클래스를 적용했습니다.